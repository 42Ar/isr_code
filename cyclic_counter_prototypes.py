#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 16 15:26:04 2022

@author: frank
"""

import matplotlib.pyplot as plt

def doit(leading, remaining, sol, sols):
    if remaining == 0:
        sols.append(sol)
    else:
        for digit in range(1, min(leading, remaining) + 1):
            doit(leading, remaining - digit, sol + [digit], sols)

x = []
y = []
for L in range(2, 25):
    sols = []
    for leading in range(1, L):
        doit(leading, L - leading, [leading], sols)
    x.append(L)
    if L == 10:
        f = sols
        print(sols)
    print(L, len(sols))
    y.append(len(sols)/L**2/4)
plt.plot(x, y)
plt.grid()
plt.yscale("log")
plt.show()

#%%

sols_check = [(2, 1, 1, 1, 1, 1, 1, 1, 1, '1101010101'),
 (2, 1, 1, 1, 1, 1, 1, 2, '1101010100'),
 (2, 1, 1, 1, 1, 1, 2, 1, '1101010110'),
 (2, 1, 1, 1, 1, 2, 1, 1, '1101010010'),
 (2, 1, 1, 1, 1, 2, 2, '1101010011'),
 (2, 1, 1, 1, 2, 1, 1, 1, '1101011010'),
 (2, 1, 1, 1, 2, 1, 2, '1101011011'),
 (2, 1, 1, 1, 2, 2, 1, '1101011001'),
 (2, 1, 1, 2, 1, 1, 1, 1, '1101001010'),
 (2, 1, 1, 2, 1, 1, 2, '1101001011'),
 (2, 1, 1, 2, 1, 2, 1, '1101001001'),
 (2, 1, 1, 2, 2, 1, 1, '1101001101'),
 (2, 1, 1, 2, 2, 2, '1101001100'),
 (2, 1, 2, 1, 1, 1, 1, 1, '1101101010'),
 (2, 1, 2, 1, 1, 1, 2, '1101101011'),
 (2, 1, 2, 1, 1, 2, 1, '1101101001'),
 (2, 1, 2, 1, 2, 1, 1, '1101101101'),
 (2, 1, 2, 1, 2, 2, '1101101100'),
 (2, 1, 2, 2, 1, 1, 1, '1101100101'),
 (2, 1, 2, 2, 1, 2, '1101100100'),
 (2, 1, 2, 2, 2, 1, '1101100110'),
 (2, 2, 1, 1, 1, 1, 1, 1, '1100101010'),
 (2, 2, 1, 1, 1, 1, 2, '1100101011'),
 (2, 2, 1, 1, 1, 2, 1, '1100101001'),
 (2, 2, 1, 1, 2, 1, 1, '1100101101'),
 (2, 2, 1, 1, 2, 2, '1100101100'),
 (2, 2, 1, 2, 1, 1, 1, '1100100101'),
 (2, 2, 1, 2, 1, 2, '1100100100'),
 (2, 2, 1, 2, 2, 1, '1100100110'),
 (2, 2, 2, 1, 1, 1, 1, '1100110101'),
 (2, 2, 2, 1, 1, 2, '1100110100'),
 (2, 2, 2, 1, 2, 1, '1100110110'),
 (2, 2, 2, 2, 1, 1, '1100110010'),
 (2, 2, 2, 2, 2, '1100110011'),
 (3, 1, 1, 1, 1, 1, 1, 1, '1110101010'),
 (3, 1, 1, 1, 1, 1, 2, '1110101011'),
 (3, 1, 1, 1, 1, 2, 1, '1110101001'),
 (3, 1, 1, 1, 1, 3, '1110101000'),
 (3, 1, 1, 1, 2, 1, 1, '1110101101'),
 (3, 1, 1, 1, 2, 2, '1110101100'),
 (3, 1, 1, 1, 3, 1, '1110101110'),
 (3, 1, 1, 2, 1, 1, 1, '1110100101'),
 (3, 1, 1, 2, 1, 2, '1110100100'),
 (3, 1, 1, 2, 2, 1, '1110100110'),
 (3, 1, 1, 2, 3, '1110100111'),
 (3, 1, 1, 3, 1, 1, '1110100010'),
 (3, 1, 1, 3, 2, '1110100011'),
 (3, 1, 2, 1, 1, 1, 1, '1110110101'),
 (3, 1, 2, 1, 1, 2, '1110110100'),
 (3, 1, 2, 1, 2, 1, '1110110110'),
 (3, 1, 2, 1, 3, '1110110111'),
 (3, 1, 2, 2, 1, 1, '1110110010'),
 (3, 1, 2, 2, 2, '1110110011'),
 (3, 1, 2, 3, 1, '1110110001'),
 (3, 1, 3, 1, 1, 1, '1110111010'),
 (3, 1, 3, 1, 2, '1110111011'),
 (3, 1, 3, 2, 1, '1110111001'),
 (3, 1, 3, 3, '1110111000'),
 (3, 2, 1, 1, 1, 1, 1, '1110010101'),
 (3, 2, 1, 1, 1, 2, '1110010100'),
 (3, 2, 1, 1, 2, 1, '1110010110'),
 (3, 2, 1, 1, 3, '1110010111'),
 (3, 2, 1, 2, 1, 1, '1110010010'),
 (3, 2, 1, 2, 2, '1110010011'),
 (3, 2, 1, 3, 1, '1110010001'),
 (3, 2, 2, 1, 1, 1, '1110011010'),
 (3, 2, 2, 1, 2, '1110011011'),
 (3, 2, 2, 2, 1, '1110011001'),
 (3, 2, 2, 3, '1110011000'),
 (3, 2, 3, 1, 1, '1110011101'),
 (3, 2, 3, 2, '1110011100'),
 (3, 3, 1, 1, 1, 1, '1110001010'),
 (3, 3, 1, 1, 2, '1110001011'),
 (3, 3, 1, 2, 1, '1110001001'),
 (3, 3, 1, 3, '1110001000'),
 (3, 3, 2, 1, 1, '1110001101'),
 (3, 3, 2, 2, '1110001100'),
 (3, 3, 3, 1, '1110001110'),
 (4, 1, 1, 1, 1, 1, 1, '1111010101'),
 (4, 1, 1, 1, 1, 2, '1111010100'),
 (4, 1, 1, 1, 2, 1, '1111010110'),
 (4, 1, 1, 1, 3, '1111010111'),
 (4, 1, 1, 2, 1, 1, '1111010010'),
 (4, 1, 1, 2, 2, '1111010011'),
 (4, 1, 1, 3, 1, '1111010001'),
 (4, 1, 1, 4, '1111010000'),
 (4, 1, 2, 1, 1, 1, '1111011010'),
 (4, 1, 2, 1, 2, '1111011011'),
 (4, 1, 2, 2, 1, '1111011001'),
 (4, 1, 2, 3, '1111011000'),
 (4, 1, 3, 1, 1, '1111011101'),
 (4, 1, 3, 2, '1111011100'),
 (4, 1, 4, 1, '1111011110'),
 (4, 2, 1, 1, 1, 1, '1111001010'),
 (4, 2, 1, 1, 2, '1111001011'),
 (4, 2, 1, 2, 1, '1111001001'),
 (4, 2, 1, 3, '1111001000'),
 (4, 2, 2, 1, 1, '1111001101'),
 (4, 2, 2, 2, '1111001100'),
 (4, 2, 3, 1, '1111001110'),
 (4, 2, 4, '1111001111'),
 (4, 3, 1, 1, 1, '1111000101'),
 (4, 3, 1, 2, '1111000100'),
 (4, 3, 2, 1, '1111000110'),
 (4, 3, 3, '1111000111'),
 (4, 4, 1, 1, '1111000010'),
 (4, 4, 2, '1111000011'),
 (5, 1, 1, 1, 1, 1, '1111101010'),
 (5, 1, 1, 1, 2, '1111101011'),
 (5, 1, 1, 2, 1, '1111101001'),
 (5, 1, 1, 3, '1111101000'),
 (5, 1, 2, 1, 1, '1111101101'),
 (5, 1, 2, 2, '1111101100'),
 (5, 1, 3, 1, '1111101110'),
 (5, 1, 4, '1111101111'),
 (5, 2, 1, 1, 1, '1111100101'),
 (5, 2, 1, 2, '1111100100'),
 (5, 2, 2, 1, '1111100110'),
 (5, 2, 3, '1111100111'),
 (5, 3, 1, 1, '1111100010'),
 (5, 3, 2, '1111100011'),
 (5, 4, 1, '1111100001'),
 (5, 5, '1111100000'),
 (6, 1, 1, 1, 1, '1111110101'),
 (6, 1, 1, 2, '1111110100'),
 (6, 1, 2, 1, '1111110110'),
 (6, 1, 3, '1111110111'),
 (6, 2, 1, 1, '1111110010'),
 (6, 2, 2, '1111110011'),
 (6, 3, 1, '1111110001'),
 (6, 4, '1111110000'),
 (7, 1, 1, 1, '1111111010'),
 (7, 1, 2, '1111111011'),
 (7, 2, 1, '1111111001'),
 (7, 3, '1111111000'),
 (8, 1, 1, '1111111101'),
 (8, 2, '1111111100'),
 (9, 1, '1111111110')]

sols = []
L = 10
alternating = sum(1 << i for i in range(0, 64, 2))
sol = [1]*(L - 2)
for leading in range(2, L):
    c = L - leading
    b = (1 << (leading - 1)) - 1
    for i in range(L - leading):
        sol[i] = 1
    runs = 0
    b = b << (c + 1)
    c += 1
    while True:
        b = ((b >> c) << c) | (alternating >> (63 - c + (runs&1)))
        runs += c - 2
        if (runs&1) == 0:
            pass
        print(f"{leading} {b:b} {[leading] + sol[:runs+1]}")
        sols.append(tuple([leading] + sol[:runs+1] + [f"{b:b}"]))
        if runs == 0:
            break
        c = sol[runs]
        sol[runs] = 1
        prev = sol[runs - 1]
        need_break = False
        while prev == leading:
            runs -= 1
            if runs == 0:
                need_break = True
                break
            c += prev
            sol[runs] = 1
            prev = sol[runs - 1]
        if need_break:
            break
        sol[runs - 1] = prev + 1
assert set(sols) == set(sols_check)


# 11110XXX10XXX10

#%%

# leading | code         stack
#       5 | 5            0
#       5 | 4 1          0
#       5 | 3 2          0, 1
#       5 | 3 1 1        0
#       5 | 2 3          0, 1
#       5 | 2 2 1        0, 2
#       5 | 2 1 2        0, 2
#       5 | 2 1 1 1      0
#       5 | 1 4          1
#       5 | 1 3 1        1
#       5 | 1 2 2        1, 2
#       5 | 1 2 1 1      1
#       5 | 1 1 3        2
#       5 | 1 1 2 1      2
#       5 | 1 1 1 2      3
#       5 | 1 1 1 1 1

# 6 | 3, RUNS((1, 1, 1)), 3 | 4, RUNS(3, (1, 1, 1)), 2 | 5, RUNS(:5), 1


L = 10
sols = []
for leading in range(2, L):
    stack = [0]*20
    sol = [0]*20
    sums = [0]*20
    remaining = L - leading
    i = 0
    while remaining > leading:
        sol[i] = leading
        remaining -= leading
        sums[i] = leading*i + leading
        stack[i] = i
        i += 1
    sums[i] = leading*i + remaining
    sol[i] = remaining
    print(leading, sums, sol, stack)
    stacksize = i
    runi = i
    while True:
        print(leading, runi, sol[:runi + 1], stack[:stacksize])
        sols.append(tuple([leading] + sol[:runi + 1]))
        if sol[runi] == 1:
            # can no longer decrease => get next runi from stack
            if stacksize == 0:
                break
            stacksize -= 1
            runi = stack[stacksize]
        sol[runi] -= 1
        sums[runi] -= 1
        remaining = L - leading - sums[runi]
        runi += 1
        sol[runi] = remaining
        sums[runi] = sums[runi - 1] + remaining
        if sol[runi - 1] > 1:
            # only save current index to stack if it has remaining
            stack[stacksize] = runi - 1
            stacksize += 1
    break